<refentry id="{@id}" revision="$Id$">
 <refnamediv>
  <refname>DateHelper</refname>
  <refpurpose>Date/time pulldown menu utilities class</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <author>
   Walt Haas
   <authorblurb>
    {@link mailto:haas@xmission.com haas@xmission.com}
   </authorblurb>
  </author>
 </refsynopsisdiv>
 {@toc}
 <refsect1 id="{@id intro}">
  <title>Introduction</title>
  <para>The {@link DateHelper} class provides a variety of utility
   methods to help construction of pulldown menus for dates and
   times.  Calls to DateHelper methods are generated by
   {@link ActiveRecordHelper::to_scaffold_tag()} in response to the
   <literal>php<entity>&nbsp;</entity>script/generate.php<entity>&nbsp;</entity>scaffold</literal> console
   command.  The call generated for each data item is chosen based 
   on the data type reported by the database for the corresponding
   column.</para>

  <para>There are two main groups of methods in the DateHelper class:
   <orderedlist>
    <listitem>Low level methods that generate a menu with a name and
     options controlled by the arguments of the method
     call.</listitem>
    <listitem>High level methods that use the name of an
     {@link ActiveRecord} subclass and one of its attributes to
     reference the database for a value.  These methods use the
     information from the database to construct arguments, then call
     corresponding low level methods to generate the HTML.</listitem>
   </orderedlist></para>

  <para>DateHelper must be instantiated before its methods can be
   called. For each DateHelper method called from a form, there is a
   corresponding function that creates an instance of DateHelper then
   passes its arguments to the relevant method of that instance.
   These functions usually have the same name as the method they call,
   and the functions are grouped together in the
   {@link date_helper.php} procedural file following the definition of
   the DateHelper class.</para>
 </refsect1>
 <refsect1 id="{@id low_level}">
  <title>Low Level Methods</title>
  <para>There are six basic low level methods:
   <itemizedlist>
    <listitem>{@link DateHelper::select_day() select_day()}</listitem>
    <listitem>{@link DateHelper::select_hour() select_hour()}</listitem>
    <listitem>{@link DateHelper::select_minute() select_minute()}</listitem>
    <listitem>{@link DateHelper::select_month() select_month()}</listitem>
    <listitem>{@link DateHelper::select_second() select_second()}</listitem>
    <listitem>{@link DateHelper::select_year() select_year()}</listitem>
   </itemizedlist>
   Each of these methods accepts two arguments, both optional:

   <orderedlist>  
    <listitem><command>First Argument: Date/Time Value</command>
     <cmdsynopsis><para>When the browser user fills in a
     form and clicks the Submit button, the browser sends a POST
     {@link http://en.wikipedia.org/wiki/HTTP HTTP} message to the web
     server with the name and value of each field of the form.  When
     PHP processes the POST message it puts the name and value of each
     field of the message into global variable
     {@link http://www.php.net/manual/en/reserved.variables.php#reserved.variables.request $_REQUEST}
     before starting execution of the Trax application.  Therefore if
     a value for a field is present in $_REQUEST, it is because the
     user specifically entered that value, or accepted a value that
     was already there.  This information is assumed to be more valid
     than the date/time value in the argument, so if a value for this
     field is defined in $_REQUEST, that value is used and the
     argument is ignored.</para>

     <para>If there is no defined value for the field in $_REQUEST,
      then the argument is used to generate the initially selected
      value in the menu, or if the argument is also omitted, 
      the current date/time is initially
      selected.</para></cmdsynopsis></listitem> 

    <listitem><command>Second Argument: Output Format Options</command>
     <cmdsynopsis>Specify the format of the HTML string returned by
     the method.  If omitted, the output will be
     in a default format.</cmdsynopsis></listitem>
   </orderedlist>

   Each of these methods returns a character string containing HTML
   defining the pulldown menu as
   <example>
&lt;select name=...&gt;
&lt;option value=...&gt; ... &lt;/option&gt;
&lt;option value=...&gt; ... &lt;/option&gt;
...
&lt;/select&gt;
   </example>
   This character string is ready to be inserted directly into a page.
  </para>
  <refsect2 id="{@id low_level_arg1}">
   <title>First Argument: Date/Time Value</title>
   <para>As mentioned above, if a DateHelper object is created as a
    result of a POST message, the values transmitted in the
    message will appear in $_REQUEST, so this value is assumed to be
    more valid than the argument value.</para>

   <para>However, the six low-level methods do not access this
    information directly from $_REQUEST.  Instead, they rely on the
    fact that
    {@link DateHelper::check_request_for_value() check_request_for_value()}
    was called previously to parse the contents of $_REQUEST and
    copy relevant values to instance variables named
    <literal>$request_</literal><arg choice="tute-comment">typename</arg><literal>s</literal>
    where <arg choice="tute-comment">typename</arg> is the type of
    time unit supported by the method (minute, month etc.).  The
    <literal>$request_</literal><arg choice="tute-comment">typename</arg><literal>s</literal>
    instance variables are arrays indexed by the name of the field, so
    that if there were two year selector fields named
    <literal>start_year</literal> and <literal>end_year</literal> in
    the POST message, <literal>check_request_for_value()</literal>
    would store their values in
    <literal>$request_years['start_year']</literal> and
    <literal>$request_years['end_year']</literal> respectively.</para>

   <para>At the time the DateHelper object is created, the name of the
    field that it processes is assigned to instance variable
    {@link Helpers::$attribute_name $attribute_name}.  So in the
    example of the two year fields named <literal>start_year</literal>
    and <literal>end_year</literal>, two DateHelper objects would be
    created, one with
    <literal>$attribute_name = 'start_year'</literal>
    and the other with
    <literal>$attribute_name = 'end_year'</literal>.  Usually this
    value is set in the object constructor call.  So when
    <literal>select_year()</literal> is called, it checks 
    <literal>$this->request_years[$this->attribute_name]</literal>
    to see if the user specified an initial value for the
    field whose name is in <literal>$attribute_name</literal>.
.</para>

  <para>If the method finds no value in
   <literal>$request_</literal><arg choice="tute-comment">typename</arg><literal>s</literal>,
   it examines the first argument.  Two types of value are
   legitimate for this argument: a string of decimal digits of exactly
   the right length and value, and a date/time description in any of
   the formats accepted by {@link PHP_MANUAL#strtotime strtotime()}.
   It is often most practical to use a single date/time value for all 
   <literal>select_</literal><arg choice="tute-comment">typename</arg><literal>()</literal>
   calls, usually the SQL format
   <literal>YYYY-MM-DD<entity>&nbsp;</entity>HH:MM:SS</literal>.
   Given an argument value in this format, the method extracts that
   part of the argument applicable to its type.  For example:
<example>
$datetime = '1997-10-23 17:46:57';
select_month($datetime);
select_day($datetime);
select_year($datetime);
</example>
    would create three menus, a month menu with initial value 'October',
    a day menu with initial value '23' and a year menu with initial
    value '1997'.</para>

  <para>The options available on each menu of course depend on the
   type. A month menu always has twelve months, a day menu always has
   31 days and so forth.  In the case of the year menu, there are a
   potentially infinite number of possible years, so the default is to
   generate options in the range of the initial value plus or
   minus five years.  The range can be changed with the second
   argument.</para>
  </refsect2>
  <refsect2 id="{@id low_level_arg2}">
   <title>Second Argument: Output Format Options</title>
   <para>The second argument to a low-level method call is an array
    in which each key is a character string naming an option, and the
    value assigned to that key is the option value, which may be either a
    character string or boolean value depending on the option.</para>

   <para>Certain options are available for all method types.  One such
    option is <literal>include_blank</literal>.  This governs whether
    or not there is a blank as one option of the menu. The default
    value is <literal>'include_blank'=>false</literal> which prevents
    the blank line.  You can specify
    <literal>'include_blank'=>true</literal> in your options array to
    cause a blank line to appear as an option.  Unfortunately there is
    currently no way to choose that as the initially selected value,
    nor to insert a line with a character string value such as
    <literal>--Select--</literal>.</para>

   <para>Three options, also available for all method types, combine
    to set the value of the <literal>name</literal> attribute of the
    output <literal>&lt;select&gt;</literal>.  They are
    <literal>prefix</literal>, 
    <literal>field_name</literal> and
    <literal>discard_type</literal>.  The default combination is
    <literal>'prefix'=>null</literal>,
    <literal>'discard_type'=>false</literal> and 
    <literal>'field_name'=></literal><arg choice="tute-comment">typename</arg>.
    The type of <literal>select_year()</literal> is
    <literal>'year'</literal>, so the method call
    <literal>select_year();</literal> is equivalent to 
    <literal>select_year(null,array('prefix'=>null,'discard_type'=>false,
    'field_name'=>'year'));</literal> which generates as  output
    <literal>&lt;select<entity>&nbsp;</entity>name="year"&gt;...&lt;/select&gt;</literal>.
    </para>

   <para>A simple change is to replace the default name, so
    <literal>select_year(null,array('field_name'=>'start_year'));</literal>
    will generate
    <literal>&lt;select<entity>&nbsp;</entity>name="start_year"&gt;...&lt;/select&gt;</literal>.
    </para>

   <para>It is also possible to insert a prefix before the name.  The
    simplest case is to insert the prefix while maintaining the
    default name: 
    <literal>select_year(null,array('prefix'=>'start_date'));</literal>
    will generate
    <literal>&lt;select<entity>&nbsp;</entity>name="start_date[year]"&gt;...&lt;/select&gt;</literal>.
    This is a handy way to assign related names to several date/time fields.
    </para>

   <para>Finally it is possible to have the prefix replace the name
    completely.  This is done with the
    <literal>'discard_type'</literal> option, which prevents output of
    the value of the
    <literal>'field_name'</literal> option.  So the method call
    <literal>select_year(null,array('prefix'=>'start_date','discard_type'=>true));</literal>
    will generate
    <literal>&lt;select<entity>&nbsp;</entity>name="start_date"&gt;...&lt;/select&gt;</literal>.
    </para>    

    <para>start_year, end_year for select_year()</para>

  </refsect2>

  <refsect2 id="{@id low_level_composite}">
   <title>Composite Methods</title>
   <para>Combine or specialize calls to low level methods</para>
   <itemizedlist>
    <listitem>{@link DateHelper::select_date() select_date()}</listitem>
    <listitem>{@link DateHelper::select_datetime()
     select_datetime()}</listitem>
    <listitem>{@link DateHelper::select_expiration_date()
     select_expiration_date()}</listitem>
    <listitem>{@link DateHelper::select_time() select_time()}</listitem>
   </itemizedlist>
    <para>options:field_separator on to_date_select_tag(). 
     Discard components</para>

  </refsect2>
 </refsect1>

 <refsect1 id="{@id high_level}">
  <title>High Level Methods</title>
  <para>Use model data as arguments for low level methods.  Page calls
   function which creates DateHelper object and calls method</para>
  <para>All use {@link DateHelper::value()} to get data from model</para>
   <itemizedlist>
    <listitem>{@link datetime_select() datetime_select() function}
     calls {@link DateHelper::datetime_select() datetime_select()
     method}</listitem>
    <listitem>{@link date_select() date_select() function} calls
     {@link DateHelper::date_select() date_select() method}</listitem>
    <listitem>{@link expiration_date_select() expiration_date_select()
     function} calls {@link DateHelper::expiration_date_select()
     expiration_date_select() method}</listitem>
    <listitem>{@link time_select() time_select() function}
     calls {@link DateHelper::time_select() time_select()
     method}</listitem>
    <listitem>{@link year_select() year_select() function}
     calls {@link DateHelper::year_select() year_select()
     method}</listitem>
   </itemizedlist>
  
 </refsect1>
<!--
Local variables:
mode: xml
c-basic-offset: 1
indent-tabs-mode: nil
End:
-->
</refentry>
